# Dynamic Loading and Linking
**Dynamic Loading**: Loading the library (or any other binary) into the memory
during load or run-time. Similar to plugins. 
**Dynamic Linking**: Linking that is done during load or run-time and not when
the executable is created. 

In Linux, there are two types of libraries: static or shared. In order to call
funcs in a static lib, you have statically link the lib into your program. 

With a dynamic libary, you can either choose to use dynamic loading or dynamic
linking. 

With a shared library, multiple programs can use it simultaneously. Whereas with
a static library, every running program has its own copy of the library. 

Static libraries end in .a. 
Dynamic libraries end in .so. 

## The LD_PRELOAD trick 
We can use the LD_PRELOAD environment variable to define our own symbols for a
given program. 

### Linux
```
gcc -shared -fPIC -o inject.so inject.c

LD_PRELOAD=$PWD/inject.so ./out
```

### OSX  
```
gcc -shared -fPIC -o inject.dylib inject.c
DYLD_INSERT_LIBRARIES=$PWD/inject.dylib DYLD_FORCE_FLAT_NAMESPACE=1 ./out
```
### Symbol Fishing 
We can retrieve original symbols using this technique. We can use the <dlfcn.h>
system lib for this. 

```
#define _GNU_SOURCE

#include <dlfcn.h>
#include <stdio.h>

typedef ssize_t (*real_read_t)(int, void *, size_t);

ssize_t real_read(int fd, void *data, size_t size) {
  return ((real_read_t)dlsym(RTLD_NEXT, "read"))(fd, data, size);
}

ssize_t read(int fd, void *data, size_t size) {
  ssize_t amount_read;

  // Perform the actual system call
  amount_read = real_read(fd, data, size);

  // Our malicious code
  fwrite(data, sizeof(char), amount_read, stdout);

  // Behave just like the regular syscall would
  return amount_read;
}
```
Recompile with -ldl flag to link the dl library 
```
gcc -shared -fPIC -ldl -o inject.so inject.c
```

You can also 
```
export LD_PRELOAD=$PWD/inject.so
```

in order to have the library always injected. 

### Another example of Symbol Fishing 
If we just did: 
```
int open(const char *pathname, int flags){
  /* Some evil injected code goes here. */
  return open(pathname,flags); // Here we call the "real" open function, that is provided to us by libc.so
}
```
It would lead to an endless recursive call. 

So, we have to do something like this, in order to access the "real" open
function: 
```
#define _GNU_SOURCE
#include <dlfcn.h>
 
typedef int (*orig_open_f_type)(const char *pathname, int flags);
 
int open(const char *pathname, int flags, ...)
{
    /* Some evil injected code goes here. */
 
    orig_open_f_type orig_open;
    orig_open = (orig_open_f_type)dlsym(RTLD_NEXT,"open");
    return orig_open(pathname,flags);
}
```
The dlfcn.h is needed for dlsym function. The strange #define directive
instruction.
