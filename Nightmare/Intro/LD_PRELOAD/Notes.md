# Dynamic Loading and Linking
**Dynamic Loading**: Loading the library (or any other binary) into the memory
during load or run-time. Similar to plugins. 
**Dynamic Linking**: Linking that is done during load or run-time and not when
the executable is created. 

In Linux, there are two types of libraries: static or shared. In order to call
funcs in a static lib, you have statically link the lib into your program. 

With a dynamic libary, you can either choose to use dynamic loading or dynamic
linking. 

With a shared library, multiple programs can use it simultaneously. Whereas with
a static library, every running program has its own copy of the library. 

Static libraries end in .a. 
Dynamic libraries end in .so. 

## The LD_PRELOAD trick 
We can use the LD_PRELOAD environment variable to define our own symbols for a
given program. 

### Linux
```
gcc -shared -fPIC -o inject.so inject.c

LD_PRELOAD=$PWD/inject.so ./out
```

### OSX  
```
gcc -shared -fPIC -o inject.dylib inject.c
DYLD_INSERT_LIBRARIES=$PWD/inject.dylib DYLD_FORCE_FLAT_NAMESPACE=1 ./out
```
### Symbol Fishing 
We can retrieve original symbols using this technique. We can use the <dlfcn.h>
system lib for this. 

```
#define _GNU_SOURCE

#include <dlfcn.h>
#include <stdio.h>

typedef ssize_t (*real_read_t)(int, void *, size_t);

ssize_t real_read(int fd, void *data, size_t size) {
  return ((real_read_t)dlsym(RTLD_NEXT, "read"))(fd, data, size);
}

ssize_t read(int fd, void *data, size_t size) {
  ssize_t amount_read;

  // Perform the actual system call
  amount_read = real_read(fd, data, size);

  // Our malicious code
  fwrite(data, sizeof(char), amount_read, stdout);

  // Behave just like the regular syscall would
  return amount_read;
}
```
Recompile with -ldl flag to link the dl library 
```
gcc -shared -fPIC -ldl -o inject.so inject.c
```


