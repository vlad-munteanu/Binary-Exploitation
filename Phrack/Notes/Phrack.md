# Phrack V.7 14/16

Created: May 24, 2020 5:46 PM
Type: Hacking

### Process Memory Organization

Processes are divided into three regions: text, data, and stack (Theres also the heap but this article is grouping the heap and stack together) 

*Data*: static variables (corresponds to the data-bss section of an executable) 

*Stack*: contiguous block of memory containing data 

- Register called stack pointer (SP) points to the top of the stack, bottom of the stack is at a fixed address
- Stack consistes of stack frames which contain the parameters to a function, its local variables, and the data necessary to recover the previous stack frame (including the value of the instruction pointer at the time of the function call)
- Base pointer register is used on most machines for referencing local vars and parameters because their distances from the base pointer (EBP on intel) do not change with push/pops

### Procedure Prologue

When a procedure is called:

1. Saves the previous base pointer (so it can be restored at procedure exit) 
2. Copies SP into base pointer
3. Advances SP to reserve space for the local variables 
4. Code is called 

```jsx
gcc -S -o
S switch generates assembly code output
```

call instruction just puts instruction pointer on stack 

arguments are pushed in reverse order on the stack because of the nature of stacks (lifo)

### Shell Code

Run arbitrary instructions by placing arbitrary code in buffer we are overflowing, overwrite the return address so it points back into the buffer

```c
The code to spawn a shell in C looks like:

shellcode.c
-----------------------------------------------------------------------------
#include <stdio.h>

void main() {
   char *name[2];

   name[0] = "/bin/sh";
   name[1] = NULL;
   execve(name[0], name, NULL);
}
------------------------------------------------------------------------------
```

Most Operating Systems mark code pages read-only, so we have to place the code we wish to execute in the stack or data segement and transger control to it. In order to get a hex representation of the binary code we can compile it and use gdb to obtain it.

to do this: 

disassemble main 

and then x/bx <inst> for every instruction 

xor reg, reg is the same as moving null into the register 

In a character array, any null byte is considered the end of a string, thus we have to keep this in mind when writing shellcode. 

```
Most programs do not push more than a few hundred 
or a few thousand bytes into the stack at any one time.
```