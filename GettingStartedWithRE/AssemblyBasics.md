# Assembly Basics 

## Central Processing Unit (CPU) Architecture 
A program runs by being loaded into primary memory (RAM), then the CPU goes to
the entry point of program. The CPU then fetches, decodes, and executes program
instructions. 

### CPU Cores and Clock Cycles 
When it is said that the "CPU" is fetching instructions, it is actually the CPU
core. A CPU can have multiple cores. CPU clock speed (# of instructions executed
per second) usually expressed in GHz. 

### Layers of Memory 
CPU Registers (Fastest memory), Caches, Primary Memory (RAM), Secondary storage,
and Input devices. 

### Processor Registers
32 bit systems are commonly considered to have 8 general purpose registers. You
can directly access individual bits of the register. 64 bit extends 32 bit general
purpose registers and adds 8 more. 

#### 32-bit pointer registers w/ 16-bit portions 
EIP: Instruction Pointer 
ESP: Stack Pointer 
EBP: Base Pointer 

(In 64 bit, the E is replaced with R.)

### 32-bit index registers w/ 16-bit portions 
ESI: Source Index 
EDI: Destination Index 

These are commonly used for copy operations. 

### EFLAGS & RFLAGS 
Represent the result of operations and state of the CPU. Each bit in these
registers represent a flag. 

## The Assembler and Program Segments 

### Binary File Formats (Exe) 
Binary files are all hex. They can be divided into two basic parts: 
1. Headers: give OS information about file 
2. Sections: Code, resources, etc 

### Segments 
- .text/.code: program instructions in binary state, entry point of program 
- .data/.idata: initialized data
- .rsrc: resources used by the program; icons, images, etc 
- .bss: uninitialized data

(Not exhaustive list of segments. Names of segments can be changed arbitrarily.
Segments are only there to help humans and not the computer.)
(Loading program in virtual memory changes location and size of segments.) 

## Instruction Set Architecture (ISA)
ISA defines the instructions the CPU understands.

### Formats of Assembly 
Mnemonics: Human-readable forms of the instructions (mov, add, sub, etc) 
Operands: Arguments expected by the instruction. These can be a few different
types: a register, a constant, or a memory location. 
OPCODES: binary representation of the instruction and any operands. Often
displayed as hexadecimal values. 

## Essential Instructions 
There are approximately 1503 instructions defined in Intel's ISA. Use Intel's
documentation to lookup unknown instructions. 

### Primary Categories for Instructions 
- Arithmetic 
- Memory 
- Comparison 
- Control Flow 
- Bit-manipulation 

### Arithmetic 
Addition: Add Dest, Source 
Subtraction: SUB Dest, Source 
(also inc, dec which increment/decrement by 1)

MUL: Unsigned multiply, uses an implicit argument. (MUL BX) 
IMUL: Signed multiply, uses one, two, or three operands 
DIV: Unsigned divide, uses an implicit argument. 
IDIV: Signed divide

### Memory 
Often necessary to move data between registers or in/out of memory (heap/stack) 
MOV instruction: mov dest, src (can be register, memory location, or constant) 
Example: mov dword ptr [ecx], 18h
    - h represents immediate value is represented in hex 
    - brackets around ecx means value at ecx contains a pointer and brackets are
      dereferencing that pointer. 
    - dword ptr means region of memory that ecx is pointing to is only 4 bytes
      of memory, this helps not try to move values that are too large to fit

### Comparison 
CMP instruction compares 2 values by performing subtraction (can be register,
mem location, or constant). Results of the comparison update corresponding flags
in the E/RFLAGS register. 

In order to have branching logic, most comparison instructions come before a
control jump. 

### Control Flow with Jumps 
Two types of jumps: unconditional (don't check the flags register, transfers
control to argument) and conditional (allows for branching logic, checks the
flags register to determine if it should take the jump.)

CALL Instruction: similar to a jump instruction, tells CPU where to go next.
However, CALL pushes the address of the next instruction onto the stack. 
CALL instruction typically followed by a RET instruction. RET pops the value on
top of the stack into EIP. This allows a function to return to where it was
called from. 

### Note on Syntax 
Two main assembly syntax: AT&T and Intel syntax. 
AT&T prefixes registers with a "%" and immediate values with a "$." Also changes
direction of operands for many instructions: instruction source, destination. 
Example: mov eax, ebx (intel), mov %ebx, %eax (AT&T). 

## Bitwise Operations, Endianness, and Size 
### Bitwise Operations 
Operations that happen at bit level. 
AND: multiplies each register bit by bit 
OR: the bit is 0 only if both bits are 0, otherwise the bit is 1 
XOR: the bit is 0 if both bits are 0 or both bits are 1. If one bit is 0 and the
other is 1 then the bit will be 1. 
NOT: flips each bit 

### Size Directives 
Need to think in terms of size and not data types. 
- quad-word (qword): 8 bytes/64 bits 
- double-word (dword): 4 bytes/32 bits 
- word: 2 bytes/16 bits 
- byte: 8 bits 
- bit: single 1 or 0 

### Endianness 
When storing data in memory, the byte order is determined by architecture. 
- Big-endian: most significant byte first 
- Little-endian: least significant byte first

